/*
 * generated by Xtext 2.16.0
 */
package org.jactr.io2.jactr.formatting2

import com.google.common.base.Strings
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.jactr.io2.jactr.modelFragment.Add
import org.jactr.io2.jactr.modelFragment.AndSlot
import org.jactr.io2.jactr.modelFragment.Buffer
import org.jactr.io2.jactr.modelFragment.Buffers
import org.jactr.io2.jactr.modelFragment.ChunkDef
import org.jactr.io2.jactr.modelFragment.ChunkType
import org.jactr.io2.jactr.modelFragment.Chunks
import org.jactr.io2.jactr.modelFragment.Condition
import org.jactr.io2.jactr.modelFragment.ConditionalSlot
import org.jactr.io2.jactr.modelFragment.Import
import org.jactr.io2.jactr.modelFragment.Match
import org.jactr.io2.jactr.modelFragment.ModelExtension
import org.jactr.io2.jactr.modelFragment.ModelFragment
import org.jactr.io2.jactr.modelFragment.ModelFragmentPackage
import org.jactr.io2.jactr.modelFragment.ModelModule
import org.jactr.io2.jactr.modelFragment.Modify
import org.jactr.io2.jactr.modelFragment.NotSlot
import org.jactr.io2.jactr.modelFragment.OrSlot
import org.jactr.io2.jactr.modelFragment.Output
import org.jactr.io2.jactr.modelFragment.PackageDeclaration
import org.jactr.io2.jactr.modelFragment.Parameters
import org.jactr.io2.jactr.modelFragment.ParametersBlock
import org.jactr.io2.jactr.modelFragment.Production
import org.jactr.io2.jactr.modelFragment.Proxy
import org.jactr.io2.jactr.modelFragment.Query
import org.jactr.io2.jactr.modelFragment.Remove
import org.jactr.io2.jactr.modelFragment.Script
import org.jactr.io2.jactr.modelFragment.SimpleSlot

class ModelFragmentFormatter extends AbstractFormatter2 {

  private boolean _tabularProductions = true;
  private boolean _tabularParameters = true;

  def dispatch void format(ModelFragment modelFragment, extension IFormattableDocument document) {
    modelFragment.package.format
    modelFragment.package.parameters.format
  }

  def dispatch void format(PackageDeclaration dec, extension IFormattableDocument document) {
    for (imp : dec.imports)
      imp.format
    dec.imports.last?.append[setNewLines(1,2,3)]

    for (module : dec.modules)
      module.format
    dec.modules.last?.append[setNewLines(1,2,3)]

    for (ext : dec.extensions)
      ext.format
    dec.extensions.last?.append[setNewLines(1,2,3)]

    dec.buffers.format

    for (element : dec.elements)
      element.format
  }

  def dispatch format(Buffers buffers, extension IFormattableDocument document) {
    buffers.prepend[setNewLines(1,2,3)]
    interior(buffers.regionFor.keyword("{").append[newLine], buffers.regionFor.keyword("}"), [indent])
    for (buffer : buffers.buffers)
      buffer.format.append[newLine]
  }

  def dispatch format(Buffer buffer, extension IFormattableDocument document) {
    buffer.regionFor.keyword("@Override").prepend[setNewLines(1, 2, 3)].append[setNewLines(1, 1, 1)]

    if (buffer.source.size > 1) {
      interior(buffer.regionFor.keyword("{").append[newLine], buffer.regionFor.keyword("}"), [indent])

      for (slot : buffer.source) {
        slot.format
        slot.append[newLine]
      }
    } else {
      interior(buffer.regionFor.keyword("{").prepend[oneSpace], buffer.regionFor.keyword("}"), [noSpace])
    }

    buffer.parameters.format
  }

  def dispatch format(Import imp, extension IFormattableDocument document) {
    imp.prepend[setNewLines(1, 1, 1 )]
  }

  def dispatch format(ModelExtension ext, extension IFormattableDocument document) {
    ext.prepend[setNewLines(1, 2, 3)]
    if (ext.parameters !== null)
      ext.parameters.format
  }

  def dispatch format(ModelModule module, extension IFormattableDocument document) {
    module.prepend[setNewLines(1, 2, 3)]
    if (module.parameters !== null)
      module.parameters.format
  }

  def dispatch void format(Chunks chunk, extension IFormattableDocument document) {

    chunk.prepend[setNewLines(1, 2, 3)]
    chunk.interior[indent]

    for (region : chunk.regionFor.keywords(",")) {
      val nl = "]".equals(region.previousSemanticRegion.text)
      region.prepend[noSpace]
      if(nl)
        region.append[newLine; autowrap]
      else
       region.append[oneSpace; autowrap]
    }

    for (c : chunk.chunks)
      c.format
  }
  
  def dispatch void format(Parameters parameters, extension IFormattableDocument document){
    parameters.prepend[setNewLines(1, 2, 3)]
    parameters.interior[indent]

    for (region : parameters.regionFor.keywords(",")) {
      region.prepend[noSpace].append[oneSpace; autowrap]
    }    
    parameters.parameters.format
  }

  /**
   * chunk & type formatting
   */
  def dispatch void format(ChunkDef chunk, extension IFormattableDocument document) {

    interior(chunk.regionFor.keyword("("), chunk.regionFor.keyword(")"), [noSpace])

    for (region : chunk.regionFor.keywords(",")) {
      region.prepend[noSpace].append[oneSpace]
    }

    for (slot : chunk.slots) {
      slot.format
    }

    chunk.parameters.format
  }

  def dispatch void format(ChunkType chunkType, extension IFormattableDocument document) {

    chunkType.prepend[setNewLines(1, 2, 3)]
    chunkType.regionFor.feature(ModelFragmentPackage.Literals.OVERRIDABLE__NAME).surround[oneSpace]

    chunkType.regionFor.keyword("extends").surround[oneSpace]

    if (chunkType.slots.size > 1) {
      interior(chunkType.regionFor.keyword("{").append[newLine], chunkType.regionFor.keyword("}").prepend[newLine], [
        indent
      ])

      try {

        val width = chunkType.slots.map[regionFor.feature(ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME).length].max +
          1

        for (slot : chunkType.slots) {
          val region = slot.regionFor.feature(ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME)
          region.append[space = Strings.repeat(" ", width - region.length)].prepend[newLine]
          slot.regionFor.keyword("=").append[oneSpace]
        }
      } catch (Exception e) {
        // regionFor may return null
      }

    } else {
      interior(chunkType.regionFor.keyword("{").prepend[oneSpace], chunkType.regionFor.keyword("}"), [noSpace])
    }

    chunkType.parameters.format
  }

  /**
   * Parameter formatting
   */
  def dispatch void format(ParametersBlock parameters, extension IFormattableDocument document) {

    val prepend = parameters.parameter.size > 1
    
    if (_tabularParameters)
      try {
        /*
         * table format
         */
        if (parameters.parameter.size > 0) {
          parameters.interior[indent]
          val width = parameters.parameter.map[regionFor.feature(ModelFragmentPackage.Literals.PARAMETER__NAME).length].
            max + 1
          for (p : parameters.parameter) {
            val region = p.regionFor.feature(ModelFragmentPackage.Literals.PARAMETER__NAME)
            region.append[space = Strings.repeat(" ", width - region.length)]
            p.regionFor.keyword(":").append[oneSpace]
            if(prepend) p.prepend[newLine]
            else p.prepend[noSpace]
          }
        } else
          interior(parameters.regionFor.keyword("["), parameters.regionFor.keyword(']'), [noSpace])
      } catch (Exception e) {
        // it is possible for regionFor.feature to return null if the feature isn't there, i.e. a typo
      }
    else {
      if (parameters.parameter.size > 0) {
        parameters.interior[indent]
        for (p : parameters.parameter) {
          p.regionFor.keyword(":").surround[oneSpace]
          if(prepend) p.prepend[newLine]
          else p.prepend[noSpace]
        }
      } else {
        interior(parameters.regionFor.keyword("["), parameters.regionFor.keyword(']'), [noSpace])
      }
    }

  }

  /**
   * Slot formatting
   */
  def dispatch void format(SimpleSlot slot, extension IFormattableDocument document) {
    if (slot.eContainer instanceof ChunkDef)
      slot.append[noSpace].regionFor.keyword("=").surround[noSpace]
    else if (slot.eContainer instanceof ChunkType)
      slot.append[noSpace].regionFor.keyword("=").surround[oneSpace]
    else {
      if (!_tabularProductions)
        slot.append[noSpace].regionFor.keyword("=").surround[oneSpace]
      else {
        val width = slot.eContainer.eAllContents.map [
          val region = regionFor.feature(ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME)
          if (region !== null)
            region.length
          else
            0
        ].max + 1
        val region = slot.regionFor.feature(ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME)
        region.append[space = Strings.repeat(' ', width - region.length)].prepend[newLine]
      }
    }
  }

  def dispatch void format(ConditionalSlot slot, extension IFormattableDocument document) {
    if (!_tabularProductions)
      slot.append[noSpace].regionFor.feature(ModelFragmentPackage.Literals.CONDITIONAL_SLOT__CONDITION).surround [
        oneSpace
      ]
    else
      try {
        val width = slot.eContainer.eAllContents.map [
          val region = regionFor.feature(ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME)
          if (region !== null)
            region.length
          else
            0
        ].max + 1
        val region = slot.regionFor.feature(ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME)
        region.append[space = Strings.repeat(' ', width - region.length)].prepend[newLine]
        if (slot.condition === Condition.EQUALS)
          slot.regionFor.feature(ModelFragmentPackage.Literals.CONDITIONAL_SLOT__CONDITION).append[space = '  ']
        else
          slot.regionFor.feature(ModelFragmentPackage.Literals.CONDITIONAL_SLOT__CONDITION).append[oneSpace]
      } catch (Exception e) {
        // regionFor.feature can return null if typo
        // e.printStackTrace
      }
  }

  def dispatch void format(OrSlot slotBlock, extension IFormattableDocument document) {

    if (slotBlock.slots.size() > 1) {
      interior(slotBlock.regionFor.keyword("{").append[newLine], slotBlock.regionFor.keyword("}"), [indent])

      for (slot : slotBlock.slots)
        slot.format.append[newLine]
    } else {
      interior(slotBlock.regionFor.keyword("{"), slotBlock.regionFor.keyword("}"), [noSpace])
      for (slot : slotBlock.slots)
        slot.format
    }
  }

  def dispatch void format(AndSlot slotBlock, extension IFormattableDocument document) {

    if (slotBlock.slots.size() > 1) {
      interior(slotBlock.regionFor.keyword("{").append[newLine], slotBlock.regionFor.keyword("}"), [indent])

      for (slot : slotBlock.slots)
        slot.format.append[newLine]
    } else {
      interior(slotBlock.regionFor.keyword("{"), slotBlock.regionFor.keyword("}"), [noSpace])
      for (slot : slotBlock.slots)
        slot.format
    }
  }

  def dispatch void format(NotSlot slotBlock, extension IFormattableDocument document) {

    if (slotBlock.slots.size() > 1) {
      interior(slotBlock.regionFor.keyword("{").append[newLine], slotBlock.regionFor.keyword("}"), [indent])

      for (slot : slotBlock.slots)
        slot.format.append[newLine]
    } else {
      interior(slotBlock.regionFor.keyword("{"), slotBlock.regionFor.keyword("}"), [noSpace])
      for (slot : slotBlock.slots)
        slot.format
    }
  }

  def dispatch void format(Production production, extension IFormattableDocument document) {

    production.prepend[setNewLines(1, 2, 3)]

    for (condition : production.conditions)
      condition.format;
      
    var pair = production.regionFor.keywordPairs("}","{").last
    pair.key.append[noSpace]
    pair.value.prepend[noSpace]  

    for (action : production.actions)
      action.format;

    production.parameters.format
  }

  def dispatch void format(Match pa, extension IFormattableDocument document) {
    pa.prepend[newLine]
    pa.surround[indent]
    pa.formatBraces(document)

    pa.isa.prepend[newLine]
    for (slot : pa.slots)
      slot.format.prepend[newLine]
  }

  def dispatch void format(Query pa, extension IFormattableDocument document) {
    pa.prepend[newLine]
    pa.surround[indent]
    pa.regionFor.keyword("?").append[noSpace]
    pa.formatBraces(document)
    for (slot : pa.slots)
      slot.format.prepend[newLine]
  }

  def dispatch void format(Add pa, extension IFormattableDocument document) {
    pa.prepend[newLine]
    pa.surround[indent]
    pa.regionFor.keyword("+").append[noSpace]
    pa.formatBraces(document)
    pa.isa.prepend[newLine]
    for (slot : pa.slots)
      slot.format.prepend[newLine]
  }

  def dispatch void format(Modify pa, extension IFormattableDocument document) {
    pa.prepend[newLine]
    pa.surround[indent]
    pa.formatBraces(document)
    for (slot : pa.slots)
      slot.format.prepend[newLine]
  }

  def dispatch void format(Remove pa, extension IFormattableDocument document) {
    pa.prepend[newLine]
    pa.surround[indent]
    pa.regionFor.keyword("-").append[noSpace]
    pa.formatBraces(document)
    for (slot : pa.slots)
      slot.format.prepend[newLine]
  }

  def dispatch void format(Output pa, extension IFormattableDocument document) {
    pa.prepend[newLine]
    pa.surround[indent]
  }

  def dispatch void format(Script pa, extension IFormattableDocument document) {
    pa.prepend[newLine]
    pa.surround[indent]
  }

  def dispatch void format(Proxy pa, extension IFormattableDocument document) {
    pa.prepend[newLine]
    pa.surround[indent]
    pa.formatBraces(document)
    for (slot : pa.slots)
      slot.format.prepend[newLine]
  }

  def void formatBraces(EObject object, extension IFormattableDocument document) {
    if (object.eAllContents.size > 0)
      interior(object.regionFor.keyword("{").append[newLine], object.regionFor.keyword("}").append[newLine].prepend [
        newLine
      ], [indent])
    else
      interior(object.regionFor.keyword("{"), object.regionFor.keyword("}"), [noSpace])
  }

}
