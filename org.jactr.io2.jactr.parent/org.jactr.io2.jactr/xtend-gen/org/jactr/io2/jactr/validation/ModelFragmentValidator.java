/**
 * generated by Xtext 2.16.0
 */
package org.jactr.io2.jactr.validation;

import com.google.common.base.Objects;
import com.google.common.collect.LinkedListMultimap;
import com.google.inject.Inject;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.jactr.io2.jactr.modelFragment.Add;
import org.jactr.io2.jactr.modelFragment.Buffer;
import org.jactr.io2.jactr.modelFragment.ChunkDef;
import org.jactr.io2.jactr.modelFragment.ChunkType;
import org.jactr.io2.jactr.modelFragment.Chunks;
import org.jactr.io2.jactr.modelFragment.ConditionalSlot;
import org.jactr.io2.jactr.modelFragment.Import;
import org.jactr.io2.jactr.modelFragment.IsaBlock;
import org.jactr.io2.jactr.modelFragment.Match;
import org.jactr.io2.jactr.modelFragment.ModelExtension;
import org.jactr.io2.jactr.modelFragment.ModelFragmentPackage;
import org.jactr.io2.jactr.modelFragment.ModelModule;
import org.jactr.io2.jactr.modelFragment.Modify;
import org.jactr.io2.jactr.modelFragment.PackageDeclaration;
import org.jactr.io2.jactr.modelFragment.Parameters;
import org.jactr.io2.jactr.modelFragment.Production;
import org.jactr.io2.jactr.modelFragment.ProductionAction;
import org.jactr.io2.jactr.modelFragment.Proxy;
import org.jactr.io2.jactr.modelFragment.Remove;
import org.jactr.io2.jactr.modelFragment.SimpleSlot;
import org.jactr.io2.jactr.modelFragment.Value;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ModelFragmentValidator extends AbstractModelFragmentValidator {
  @Inject
  @Extension
  private ModelFragmentUtil _modelFragmentUtil;
  
  @Inject
  private IClassNameValidator _classNameValidator;
  
  public static final String BAD_PACKAGE = "badPackage";
  
  public static final String BAD_SLOT_NAME = "badSlotName";
  
  public static final String SHADOW_SLOT_NAME = "shadowSlotName";
  
  public static final String CYCLIC_TYPE = "cyclicType";
  
  public static final String BAD_VARIABLE = "badVariable";
  
  public static final String REDEFINED = "redefined";
  
  public static final String UNKNOWN_CHUNK = "unknownChunk";
  
  @Override
  public void handleExceptionDuringValidation(final Throwable targetException) throws RuntimeException {
    targetException.printStackTrace();
    super.handleExceptionDuringValidation(targetException);
  }
  
  public boolean isValidClassName(final Resource resource, final String className) {
    return this._classNameValidator.isValidClassName(resource, className);
  }
  
  @Check(CheckType.NORMAL)
  public void checkPackagePath(final PackageDeclaration dec) {
    if (((dec.getName().indexOf("-") != (-1)) || (dec.getName().indexOf(":") != (-1)))) {
      this.error("Namespaces should not include characters -,:", ModelFragmentPackage.Literals.PACKAGE_DECLARATION__NAME, 
        ModelFragmentValidator.BAD_PACKAGE);
    }
    final String packagePath = dec.getName().replace(".", "/");
    String path = dec.eResource().getURI().path();
    int _lastIndexOf = path.lastIndexOf(dec.eResource().getURI().fileExtension());
    int _minus = (_lastIndexOf - 1);
    path = path.substring(0, _minus);
    boolean _endsWith = path.endsWith(packagePath);
    boolean _not = (!_endsWith);
    if (_not) {
      this.error(((((("Namespace " + packagePath) + " should be stored under the subpath ") + packagePath) + " not ") + path), 
        ModelFragmentPackage.Literals.PACKAGE_DECLARATION__NAME, ModelFragmentValidator.BAD_PACKAGE);
    }
    final Map<String, IEObjectDescription> visibleExternal = this._modelFragmentUtil.getVisibleEObjectDescriptionsByType(dec, dec.eClass());
    final String qualified = dec.getName();
    boolean _containsKey = visibleExternal.containsKey(qualified);
    if (_containsKey) {
      String _name = dec.getName();
      String _plus = ("Package " + _name);
      String _plus_1 = (_plus + " is already defined ");
      String _path = visibleExternal.get(qualified).getEObjectURI().path();
      String _plus_2 = (_plus_1 + _path);
      String _plus_3 = (_plus_2 + ".");
      this.error(_plus_3, dec, 
        ModelFragmentPackage.Literals.PACKAGE_DECLARATION__NAME, ModelFragmentValidator.BAD_PACKAGE);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkImportsOnClasspath(final Import importDec) {
    String _importedNamespace = importDec.getImportedNamespace();
    int _length = importDec.getImportedNamespace().length();
    int _minus = (_length - 2);
    String _replace = _importedNamespace.substring(0, _minus).replace(".", "/");
    String resource = (_replace + 
      ".jactr");
    boolean _canResolve = this._classNameValidator.canResolve(importDec.eResource(), resource);
    boolean _not = (!_canResolve);
    if (_not) {
      this.error((("Could not find " + resource) + " in classpath"), importDec, 
        ModelFragmentPackage.Literals.IMPORT__IMPORTED_NAMESPACE);
      this._modelFragmentUtil.dump(importDec.eResource());
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkSlotValues(final PackageDeclaration packageDec) {
    final HashMap<String, IEObjectDescription> symbolTable = this._modelFragmentUtil.fullSymbolTable(packageDec);
    final List<Value> allValues = EcoreUtil2.<Value>getAllContentsOfType(packageDec, Value.class);
    final Consumer<Value> _function = (Value value) -> {
      boolean _isID = this._modelFragmentUtil.isID(value);
      if (_isID) {
        EReference literal = ModelFragmentPackage.Literals.SIMPLE_SLOT__VALUE;
        EObject _eContainer = value.eContainer();
        if ((_eContainer instanceof ConditionalSlot)) {
          literal = ModelFragmentPackage.Literals.CONDITIONAL_SLOT__VALUE;
        }
        boolean _containsKey = symbolTable.containsKey(value.getName());
        boolean _not = (!_containsKey);
        if (_not) {
          String _name = value.getName();
          String _plus = (_name + " is an unknown symbol.");
          this.error(_plus, value.eContainer(), literal, ModelFragmentValidator.UNKNOWN_CHUNK, value.getName());
        } else {
          final EClass ref = symbolTable.get(value.getName()).getEClass();
          if (((!ref.getName().equals("ChunkDef")) && (!ref.getName().equals("ChunkType")))) {
            String _name_1 = value.getName();
            String _plus_1 = ("Are you sure you mean " + _name_1);
            String _plus_2 = (_plus_1 + ", it\'s a ");
            String _name_2 = ref.getName();
            String _plus_3 = (_plus_2 + _name_2);
            this.warning(_plus_3, value.eContainer(), literal);
          }
        }
      }
    };
    allValues.forEach(_function);
  }
  
  @Check(CheckType.NORMAL)
  public void checkParameterIds(final Parameters parametersDef) {
    final HashMap<String, IEObjectDescription> symbolTable = this._modelFragmentUtil.fullSymbolTable(parametersDef);
    final AtomicInteger integer = new AtomicInteger(0);
    final Consumer<String> _function = (String id) -> {
      IEObjectDescription _get = symbolTable.get(id);
      boolean _tripleEquals = (_get == null);
      if (_tripleEquals) {
        this.error((id + " is an unknown symbol."), parametersDef, ModelFragmentPackage.Literals.PARAMETERS__ELEMENTS, 
          integer.get(), ModelFragmentValidator.UNKNOWN_CHUNK, id);
      }
      integer.incrementAndGet();
    };
    parametersDef.getElements().forEach(_function);
  }
  
  @Check(CheckType.FAST)
  public void checkClassnameOfModule(final ModelModule module) {
    boolean _isValidClassName = this.isValidClassName(module.eResource(), module.getModuleClass());
    boolean _not = (!_isValidClassName);
    if (_not) {
      String _moduleClass = module.getModuleClass();
      String _plus = (_moduleClass + " could not be found in current classpath");
      this.error(_plus, module, 
        ModelFragmentPackage.Literals.MODEL_MODULE__MODULE_CLASS);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkClassnameOfExtension(final ModelExtension ext) {
    boolean _isValidClassName = this.isValidClassName(ext.eResource(), ext.getExtensionClass());
    boolean _not = (!_isValidClassName);
    if (_not) {
      String _extensionClass = ext.getExtensionClass();
      String _plus = (_extensionClass + " could not be found in current classpath");
      this.error(_plus, ext, 
        ModelFragmentPackage.Literals.MODEL_EXTENSION__EXTENSION_CLASS);
    }
  }
  
  /**
   * does this slotName exist in the chunktype hierarchy
   */
  public boolean isValidSlot(final ChunkType type, final String slotName) {
    boolean _xblockexpression = false;
    {
      ChunkType cType = type;
      final HashSet<ChunkType> visited = new HashSet<ChunkType>();
      while ((cType != null)) {
        {
          boolean _contains = visited.contains(cType);
          if (_contains) {
            return false;
          }
          visited.add(cType);
          EList<SimpleSlot> _slots = cType.getSlots();
          for (final SimpleSlot slot : _slots) {
            boolean _equals = slot.getName().equals(slotName);
            if (_equals) {
              return true;
            }
          }
          cType = type.getSuperType();
        }
      }
      _xblockexpression = false;
    }
    return _xblockexpression;
  }
  
  /**
   * Chunk validation
   */
  @Check(CheckType.FAST)
  public void checkSlotsOf(final Chunks chunks) {
    final ChunkType chunkType = chunks.getType();
    final HashSet<String> knownSlots = this._modelFragmentUtil.allSlotNames(chunkType);
    EList<ChunkDef> _chunks = chunks.getChunks();
    for (final ChunkDef chunk : _chunks) {
      EList<SimpleSlot> _slots = chunk.getSlots();
      for (final SimpleSlot slot : _slots) {
        boolean _contains = knownSlots.contains(slot.getName());
        boolean _not = (!_contains);
        if (_not) {
          String _name = slot.getName();
          String _plus = (_name + " is not a known slot in ");
          String _name_1 = chunkType.getName();
          String _plus_1 = (_plus + _name_1);
          String _plus_2 = (_plus_1 + " available:");
          String _plus_3 = (_plus_2 + knownSlots);
          this.error(_plus_3, slot, 
            ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME, ((String[])Conversions.unwrapArray(knownSlots, String.class)));
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkUniqueChunk(final ChunkDef chunkDef) {
    final Function1<Chunks, EList<ChunkDef>> _function = (Chunks chunks) -> {
      return chunks.getChunks();
    };
    final Function1<ChunkDef, Boolean> _function_1 = (ChunkDef node) -> {
      return Boolean.valueOf((!Objects.equal(node, chunkDef)));
    };
    final Function1<ChunkDef, String> _function_2 = (ChunkDef node) -> {
      return node.getName();
    };
    final Function1<String, Boolean> _function_3 = (String name) -> {
      return Boolean.valueOf(name.equals(chunkDef.getName()));
    };
    final String existing = IterableExtensions.<String>last(IterableExtensions.<String>filter(IterableExtensions.<ChunkDef, String>map(IterableExtensions.<ChunkDef>filter(IterableExtensions.<Chunks, ChunkDef>flatMap(EcoreUtil2.<Chunks>getAllContentsOfType(EcoreUtil.getRootContainer(chunkDef, false), Chunks.class), _function), _function_1), _function_2), _function_3));
    if (((existing != null) && (!chunkDef.isOverride()))) {
      String _name = chunkDef.getName();
      String _plus = (_name + " is already defined in this file. Use @Override to replace");
      this.error(_plus, chunkDef, 
        ModelFragmentPackage.Literals.OVERRIDABLE__NAME, ModelFragmentValidator.REDEFINED);
      return;
    }
    final Map<String, IEObjectDescription> visibleExternal = this._modelFragmentUtil.getVisibleEObjectDescriptionsByType(chunkDef, chunkDef.eClass());
    final String qualified = chunkDef.getName();
    if ((visibleExternal.containsKey(qualified) && (!chunkDef.isOverride()))) {
      String _name_1 = chunkDef.getName();
      String _plus_1 = (_name_1 + " is already defined in ");
      String _path = visibleExternal.get(qualified).getEObjectURI().path();
      String _plus_2 = (_plus_1 + _path);
      String _plus_3 = (_plus_2 + 
        ". Use @Override to replace");
      this.error(_plus_3, chunkDef, ModelFragmentPackage.Literals.OVERRIDABLE__NAME, ModelFragmentValidator.REDEFINED);
    }
  }
  
  /**
   * chunktype validation
   */
  @Check(CheckType.FAST)
  public void checkSlotsOf(final ChunkType chunkType) {
    final HashSet<String> knownSlots = this._modelFragmentUtil.allSlotNames(chunkType.getSuperType());
    EList<SimpleSlot> _slots = chunkType.getSlots();
    for (final SimpleSlot slot : _slots) {
      boolean _contains = knownSlots.contains(slot.getName());
      if (_contains) {
        String _name = slot.getName();
        String _plus = (_name + " shadows a slot defined by its supertype. Default value overridden");
        this.warning(_plus, slot, 
          ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME, ModelFragmentValidator.SHADOW_SLOT_NAME);
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkUniqueChunkType(final ChunkType chunkType) {
    final Function1<ChunkType, Boolean> _function = (ChunkType node) -> {
      return Boolean.valueOf((!Objects.equal(node, chunkType)));
    };
    final Function1<ChunkType, String> _function_1 = (ChunkType node) -> {
      return node.getName();
    };
    final Function1<String, Boolean> _function_2 = (String name) -> {
      return Boolean.valueOf(name.equals(chunkType.getName()));
    };
    final String existing = IterableExtensions.<String>last(IterableExtensions.<String>filter(IterableExtensions.<ChunkType, String>map(IterableExtensions.<ChunkType>filter(EcoreUtil2.<ChunkType>getAllContentsOfType(chunkType.eContainer(), ChunkType.class), _function), _function_1), _function_2));
    if (((existing != null) && (!chunkType.isOverride()))) {
      String _name = chunkType.getName();
      String _plus = (_name + " is already defined elsewhere in this source. Use @Override to replace");
      this.error(_plus, chunkType, 
        ModelFragmentPackage.Literals.OVERRIDABLE__NAME, ModelFragmentValidator.REDEFINED);
      return;
    }
    final Map<String, IEObjectDescription> visibleExternal = this._modelFragmentUtil.getVisibleEObjectDescriptionsByType(chunkType, chunkType.eClass());
    final String qualified = chunkType.getName();
    if ((visibleExternal.containsKey(qualified) && (!chunkType.isOverride()))) {
      String _name_1 = chunkType.getName();
      String _plus_1 = (_name_1 + " is already defined ");
      String _path = visibleExternal.get(qualified).getEObjectURI().path();
      String _plus_2 = (_plus_1 + _path);
      String _plus_3 = (_plus_2 + 
        ". Use @Override to replace");
      this.error(_plus_3, chunkType, ModelFragmentPackage.Literals.OVERRIDABLE__NAME, ModelFragmentValidator.REDEFINED);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkUniqueProduction(final Production production) {
    final Function1<Production, Boolean> _function = (Production node) -> {
      return Boolean.valueOf((!Objects.equal(node, production)));
    };
    final Function1<Production, String> _function_1 = (Production node) -> {
      return node.getName();
    };
    final Function1<String, Boolean> _function_2 = (String name) -> {
      return Boolean.valueOf(name.equals(production.getName()));
    };
    final String existing = IterableExtensions.<String>last(IterableExtensions.<String>filter(IterableExtensions.<Production, String>map(IterableExtensions.<Production>filter(EcoreUtil2.<Production>getAllContentsOfType(production.eContainer(), Production.class), _function), _function_1), _function_2));
    if (((existing != null) && (!production.isOverride()))) {
      String _name = production.getName();
      String _plus = (_name + " is already defined elsewhere in this source. Use @Override to replace");
      this.error(_plus, production, 
        ModelFragmentPackage.Literals.OVERRIDABLE__NAME, ModelFragmentValidator.REDEFINED);
      return;
    }
    final Map<String, IEObjectDescription> visibleExternal = this._modelFragmentUtil.getVisibleEObjectDescriptionsByType(production, production.eClass());
    final String qualified = production.getName();
    if ((visibleExternal.containsKey(qualified) && (!production.isOverride()))) {
      String _name_1 = production.getName();
      String _plus_1 = (_name_1 + " is already defined ");
      String _path = visibleExternal.get(qualified).getEObjectURI().path();
      String _plus_2 = (_plus_1 + _path);
      String _plus_3 = (_plus_2 + 
        ". Use @Override to replace");
      this.error(_plus_3, production, ModelFragmentPackage.Literals.OVERRIDABLE__NAME, ModelFragmentValidator.REDEFINED);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void checkUniqueBuffer(final Buffer buffer) {
    final Function1<Buffer, Boolean> _function = (Buffer node) -> {
      return Boolean.valueOf((node != buffer));
    };
    final Function1<Buffer, String> _function_1 = (Buffer node) -> {
      return node.getName();
    };
    final Function1<String, Boolean> _function_2 = (String name) -> {
      return Boolean.valueOf(name.equals(buffer.getName()));
    };
    final String existing = IterableExtensions.<String>last(IterableExtensions.<String>filter(IterableExtensions.<Buffer, String>map(IterableExtensions.<Buffer>filter(EcoreUtil2.<Buffer>getAllContentsOfType(buffer.eContainer(), Buffer.class), _function), _function_1), _function_2));
    if (((existing != null) && (!buffer.isOverride()))) {
      String _name = buffer.getName();
      String _plus = (_name + " is already defined elsewhere in this source. Use @Override to replace");
      this.error(_plus, buffer, 
        ModelFragmentPackage.Literals.OVERRIDABLE__NAME, ModelFragmentValidator.REDEFINED);
      return;
    }
    final LinkedListMultimap<String, IEObjectDescription> visibleExternal = this._modelFragmentUtil.bufferSymbolTable(buffer);
    final String qualified = buffer.getName();
    if (((visibleExternal.get(qualified).size() > 1) && (!buffer.isOverride()))) {
      final Function<IEObjectDescription, String> _function_3 = (IEObjectDescription node) -> {
        return node.getEObjectURI().path();
      };
      final Predicate<String> _function_4 = (String name) -> {
        boolean _equals = name.equals(buffer.eResource().getURI().path());
        return (!_equals);
      };
      Optional<String> inWho = visibleExternal.get(qualified).stream().<String>map(_function_3).filter(_function_4).findFirst();
      boolean _isPresent = inWho.isPresent();
      if (_isPresent) {
        String _name_1 = buffer.getName();
        String _plus_1 = (_name_1 + " is already defined in ");
        String _get = inWho.get();
        String _plus_2 = (_plus_1 + _get);
        String _plus_3 = (_plus_2 + ". Use @Override to replace");
        this.error(_plus_3, buffer, 
          ModelFragmentPackage.Literals.OVERRIDABLE__NAME, ModelFragmentValidator.REDEFINED);
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkCyclicChunkType(final ChunkType chunkType) {
    boolean _contains = this._modelFragmentUtil.chunkTypeHierarchy(chunkType).contains(chunkType);
    if (_contains) {
      String _name = chunkType.getName();
      String _plus = (_name + " has a cyclic dependency.");
      this.error(_plus, chunkType.getSuperType(), 
        ModelFragmentPackage.Literals.CHUNK_TYPE__SUPER_TYPE, ModelFragmentValidator.CYCLIC_TYPE);
    }
  }
  
  /**
   * Match in three flavors
   */
  @Check(CheckType.FAST)
  public void checkSlotsOfMatch(final Match match) {
    Set<String> allSlotNames = Collections.<String>emptySet();
    ChunkType _type = match.getIsa().getType();
    boolean _tripleNotEquals = (_type != null);
    if (_tripleNotEquals) {
      allSlotNames = this._modelFragmentUtil.allSlotNames(match.getIsa().getType());
    }
    ChunkDef _chunk = match.getIsa().getChunk();
    boolean _tripleNotEquals_1 = (_chunk != null);
    if (_tripleNotEquals_1) {
      allSlotNames = this._modelFragmentUtil.allSlotNames(match.getIsa().getChunk());
    }
    String _name = match.getIsa().getName();
    boolean _tripleNotEquals_2 = (_name != null);
    if (_tripleNotEquals_2) {
      final IsaBlock variableRef = match.getIsa();
      EObject _eContainer = match.eContainer();
      final HashSet<String> variables = this._modelFragmentUtil.variables(((Production) _eContainer));
      EObject _eContainer_1 = match.eContainer();
      final boolean hasProxyOrScript = this._modelFragmentUtil.couldHaveHiddenBindings(((Production) _eContainer_1));
      boolean _contains = variables.contains(variableRef.getName());
      boolean _not = (!_contains);
      if (_not) {
        if ((!hasProxyOrScript)) {
          String _name_1 = variableRef.getName();
          String _plus = (_name_1 + " was not bound on left hand side");
          this.error(_plus, match, ModelFragmentPackage.Literals.MATCH__ISA, 
            ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
        } else {
          String _name_2 = variableRef.getName();
          String _plus_1 = (_name_2 + " was not explicitly bound, but could be by proxy or script");
          this.warning(_plus_1, match, 
            ModelFragmentPackage.Literals.MATCH__ISA, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
        }
      }
      List<ConditionalSlot> _allContentsOfType = EcoreUtil2.<ConditionalSlot>getAllContentsOfType(match, ConditionalSlot.class);
      for (final ConditionalSlot slot : _allContentsOfType) {
        boolean _startsWith = slot.getName().startsWith(":");
        if (_startsWith) {
          String _name_3 = slot.getName();
          String _plus_2 = (_name_3 + " is not valid. :state shorthand is not permitted. Use separate query instead");
          this.error(_plus_2, slot, 
            ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME);
        } else {
          boolean _startsWith_1 = slot.getName().startsWith("=");
          if (_startsWith_1) {
            boolean _contains_1 = variables.contains(slot.getName());
            boolean _not_1 = (!_contains_1);
            if (_not_1) {
              if ((!hasProxyOrScript)) {
                String _name_4 = slot.getName();
                String _plus_3 = (_name_4 + " was not bound on left hand side");
                this.error(_plus_3, slot, 
                  ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
              } else {
                String _name_5 = slot.getName();
                String _plus_4 = (_name_5 + " was not explicitly bound, but could be by proxy or script");
                this.warning(_plus_4, slot, 
                  ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
              }
            }
          } else {
            String _name_6 = slot.getName();
            String _plus_5 = (_name_6 + " could not be validated at compile. Can only be inferred at runtime. ");
            this.warning(_plus_5, slot, 
              ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME);
          }
        }
      }
    } else {
      List<ConditionalSlot> _allContentsOfType_1 = EcoreUtil2.<ConditionalSlot>getAllContentsOfType(match, ConditionalSlot.class);
      for (final ConditionalSlot slot_1 : _allContentsOfType_1) {
        boolean _startsWith_2 = slot_1.getName().startsWith(":");
        if (_startsWith_2) {
          String _name_7 = slot_1.getName();
          String _plus_6 = (_name_7 + " is not valid. :state shorthand is not permitted. Use separate query instead");
          final Set<String> _converted_allSlotNames = (Set<String>)allSlotNames;
          this.error(_plus_6, slot_1, 
            ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME, ((String[])Conversions.unwrapArray(_converted_allSlotNames, String.class)));
        } else {
          boolean _startsWith_3 = slot_1.getName().startsWith("=");
          if (_startsWith_3) {
            EObject _eContainer_2 = match.eContainer();
            final HashSet<String> variables_1 = this._modelFragmentUtil.variables(((Production) _eContainer_2));
            EObject _eContainer_3 = match.eContainer();
            final boolean hasProxyOrScript_1 = this._modelFragmentUtil.couldHaveHiddenBindings(((Production) _eContainer_3));
            boolean _contains_2 = variables_1.contains(slot_1.getName());
            boolean _not_2 = (!_contains_2);
            if (_not_2) {
              if ((!hasProxyOrScript_1)) {
                String _name_8 = slot_1.getName();
                String _plus_7 = (_name_8 + " was not bound on left hand side");
                this.error(_plus_7, slot_1, 
                  ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables_1, String.class)));
              } else {
                String _name_9 = slot_1.getName();
                String _plus_8 = (_name_9 + " was not explicitly bound, but could be by proxy or script");
                this.warning(_plus_8, slot_1, 
                  ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables_1, String.class)));
              }
            }
          } else {
            boolean _contains_3 = allSlotNames.contains(slot_1.getName());
            boolean _not_3 = (!_contains_3);
            if (_not_3) {
              String _name_10 = slot_1.getName();
              String _plus_9 = (_name_10 + " is not a known slot. available:");
              String _plus_10 = (_plus_9 + allSlotNames);
              final Set<String> _converted_allSlotNames_1 = (Set<String>)allSlotNames;
              this.error(_plus_10, slot_1, 
                ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME, ((String[])Conversions.unwrapArray(_converted_allSlotNames_1, String.class)));
            }
          }
        }
      }
    }
  }
  
  /**
   * three flavors of Add (type, chunk, variable)
   */
  @Check(CheckType.FAST)
  public void checkSlotsOfAddWithChunkType(final Add match) {
    Set<String> allSlotNames = Collections.<String>emptySet();
    IsaBlock _isa = match.getIsa();
    boolean _tripleEquals = (_isa == null);
    if (_tripleEquals) {
      final Function1<Match, Boolean> _function = (Match m) -> {
        return Boolean.valueOf(match.getName().getName().equals(m.getName().getName()));
      };
      final Iterable<Match> mates = IterableExtensions.<Match>filter(EcoreUtil2.<Match>getAllContentsOfType(match.eContainer(), Match.class), _function);
      final Function1<Match, Boolean> _function_1 = (Match m) -> {
        return Boolean.valueOf(((m.getIsa().getType() != null) || (m.getIsa().getChunk() != null)));
      };
      Match _last = IterableExtensions.<Match>last(IterableExtensions.<Match>filter(mates, _function_1));
      final Match mate = ((Match) _last);
      if ((mate != null)) {
        ChunkType _type = mate.getIsa().getType();
        boolean _tripleNotEquals = (_type != null);
        if (_tripleNotEquals) {
          allSlotNames = this._modelFragmentUtil.allSlotNames(mate.getIsa().getType());
        }
        ChunkDef _chunk = mate.getIsa().getChunk();
        boolean _tripleNotEquals_1 = (_chunk != null);
        if (_tripleNotEquals_1) {
          allSlotNames = this._modelFragmentUtil.allSlotNames(mate.getIsa().getChunk());
        }
      }
    } else {
      ChunkType _type_1 = match.getIsa().getType();
      boolean _tripleNotEquals_2 = (_type_1 != null);
      if (_tripleNotEquals_2) {
        allSlotNames = this._modelFragmentUtil.allSlotNames(match.getIsa().getType());
      } else {
        ChunkDef _chunk_1 = match.getIsa().getChunk();
        boolean _tripleNotEquals_3 = (_chunk_1 != null);
        if (_tripleNotEquals_3) {
          allSlotNames = this._modelFragmentUtil.allSlotNames(match.getIsa().getChunk());
        }
      }
    }
    if (((match.getIsa() != null) && (match.getIsa().getName() != null))) {
      final IsaBlock variableRef = match.getIsa();
      EObject _eContainer = match.eContainer();
      final HashSet<String> variables = this._modelFragmentUtil.variables(((Production) _eContainer));
      EObject _eContainer_1 = match.eContainer();
      final boolean hasProxyOrScript = this._modelFragmentUtil.couldHaveHiddenBindings(((Production) _eContainer_1));
      boolean _contains = variables.contains(variableRef.getName());
      boolean _not = (!_contains);
      if (_not) {
        if ((!hasProxyOrScript)) {
          String _name = variableRef.getName();
          String _plus = (_name + " was not bound on left hand side");
          this.error(_plus, match, ModelFragmentPackage.Literals.ADD__ISA, 
            ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
        } else {
          String _name_1 = variableRef.getName();
          String _plus_1 = (_name_1 + " was not explicitly bound, but could be by proxy or script");
          this.warning(_plus_1, match, 
            ModelFragmentPackage.Literals.ADD__ISA, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
        }
      }
      List<ConditionalSlot> _allContentsOfType = EcoreUtil2.<ConditionalSlot>getAllContentsOfType(match, ConditionalSlot.class);
      for (final ConditionalSlot slot : _allContentsOfType) {
        boolean _startsWith = slot.getName().startsWith("=");
        if (_startsWith) {
          boolean _contains_1 = variables.contains(slot.getName());
          boolean _not_1 = (!_contains_1);
          if (_not_1) {
            if ((!hasProxyOrScript)) {
              String _name_2 = slot.getName();
              String _plus_2 = (_name_2 + " was not bound on left hand side");
              this.error(_plus_2, slot, 
                ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
            } else {
              String _name_3 = slot.getName();
              String _plus_3 = (_name_3 + " was not explicitly bound, but could be by proxy or script");
              this.warning(_plus_3, slot, 
                ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
            }
          }
        } else {
          boolean _startsWith_1 = slot.getName().startsWith(":");
          boolean _not_2 = (!_startsWith_1);
          if (_not_2) {
            String _name_4 = slot.getName();
            String _plus_4 = (_name_4 + " could not be validated at compile. Can only be inferred at runtime. ");
            this.warning(_plus_4, slot, 
              ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME);
          }
        }
      }
    } else {
      List<ConditionalSlot> _allContentsOfType_1 = EcoreUtil2.<ConditionalSlot>getAllContentsOfType(match, ConditionalSlot.class);
      for (final ConditionalSlot slot_1 : _allContentsOfType_1) {
        boolean _startsWith_2 = slot_1.getName().startsWith("=");
        if (_startsWith_2) {
          EObject _eContainer_2 = match.eContainer();
          final HashSet<String> variables_1 = this._modelFragmentUtil.variables(((Production) _eContainer_2));
          EObject _eContainer_3 = match.eContainer();
          final boolean hasProxyOrScript_1 = this._modelFragmentUtil.couldHaveHiddenBindings(((Production) _eContainer_3));
          boolean _contains_2 = variables_1.contains(slot_1.getName());
          boolean _not_3 = (!_contains_2);
          if (_not_3) {
            if ((!hasProxyOrScript_1)) {
              String _name_5 = slot_1.getName();
              String _plus_5 = (_name_5 + " was not bound on left hand side");
              this.error(_plus_5, slot_1, 
                ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables_1, String.class)));
            } else {
              String _name_6 = slot_1.getName();
              String _plus_6 = (_name_6 + " was not explicitly bound, but could be by proxy or script");
              this.warning(_plus_6, slot_1, 
                ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables_1, String.class)));
            }
          }
        } else {
          if (((!allSlotNames.contains(slot_1.getName())) && (!slot_1.getName().startsWith(":")))) {
            String _name_7 = slot_1.getName();
            String _plus_7 = (_name_7 + " is not a known slot. available:");
            String _plus_8 = (_plus_7 + allSlotNames);
            final Set<String> _converted_allSlotNames = (Set<String>)allSlotNames;
            this.error(_plus_8, slot_1, 
              ModelFragmentPackage.Literals.CONDITIONAL_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME, ((String[])Conversions.unwrapArray(_converted_allSlotNames, String.class)));
          }
        }
      }
    }
  }
  
  /**
   * Modify
   */
  @Check(CheckType.FAST)
  public void checkSlotsOfModify(final Modify modify) {
    final Function1<Match, Boolean> _function = (Match match) -> {
      return Boolean.valueOf(modify.getName().getName().equals(match.getName().getName()));
    };
    final Iterable<Match> mates = IterableExtensions.<Match>filter(EcoreUtil2.<Match>getAllContentsOfType(modify.eContainer(), Match.class), _function);
    final Function1<Match, Boolean> _function_1 = (Match match) -> {
      return Boolean.valueOf(((match.getIsa().getType() != null) || (match.getIsa().getChunk() != null)));
    };
    Match _last = IterableExtensions.<Match>last(IterableExtensions.<Match>filter(mates, _function_1));
    final Match mate = ((Match) _last);
    int _size = IterableExtensions.size(mates);
    boolean _equals = (_size == 0);
    if (_equals) {
      String _name = modify.getName().getName();
      String _plus = (_name + " was never referenced on the left hand side");
      this.error(_plus, modify, 
        ModelFragmentPackage.Literals.SIMPLE_SLOT_BLOCK__NAME);
      return;
    }
    HashSet<String> allSlotNames = new HashSet<String>();
    if (((mate != null) && (mate.getIsa() != null))) {
      ChunkType _type = mate.getIsa().getType();
      boolean _tripleNotEquals = (_type != null);
      if (_tripleNotEquals) {
        allSlotNames = this._modelFragmentUtil.allSlotNames(mate.getIsa().getType());
      }
      ChunkDef _chunk = mate.getIsa().getChunk();
      boolean _tripleNotEquals_1 = (_chunk != null);
      if (_tripleNotEquals_1) {
        allSlotNames = this._modelFragmentUtil.allSlotNames(mate.getIsa().getChunk());
      }
    }
    List<SimpleSlot> _allContentsOfType = EcoreUtil2.<SimpleSlot>getAllContentsOfType(modify, SimpleSlot.class);
    for (final SimpleSlot slot : _allContentsOfType) {
      boolean _startsWith = slot.getName().startsWith("=");
      if (_startsWith) {
        EObject _eContainer = modify.eContainer();
        final HashSet<String> variables = this._modelFragmentUtil.variables(((Production) _eContainer));
        EObject _eContainer_1 = modify.eContainer();
        final boolean hasProxyOrScript = this._modelFragmentUtil.couldHaveHiddenBindings(((Production) _eContainer_1));
        boolean _contains = variables.contains(slot.getName());
        boolean _not = (!_contains);
        if (_not) {
          if ((!hasProxyOrScript)) {
            String _name_1 = slot.getName();
            String _plus_1 = (_name_1 + " was not bound on left hand side");
            this.error(_plus_1, slot, ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME, 
              ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
          } else {
            String _name_2 = slot.getName();
            String _plus_2 = (_name_2 + " was not explicitly bound, but could be by proxy or script");
            this.warning(_plus_2, slot, 
              ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
          }
        }
      } else {
        boolean _contains_1 = allSlotNames.contains(slot.getName());
        boolean _not_1 = (!_contains_1);
        if (_not_1) {
          String _name_3 = slot.getName();
          String _plus_3 = (_name_3 + " is not a known slot. available:");
          String _plus_4 = (_plus_3 + allSlotNames);
          final HashSet<String> _converted_allSlotNames = (HashSet<String>)allSlotNames;
          this.error(_plus_4, slot, 
            ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME, ((String[])Conversions.unwrapArray(_converted_allSlotNames, String.class)));
        }
      }
    }
  }
  
  /**
   * Remove
   */
  @Check(CheckType.FAST)
  public void checkSlotsOfRemove(final Remove remove) {
    final Function1<Match, Boolean> _function = (Match match) -> {
      return Boolean.valueOf(remove.getName().getName().equals(match.getName().getName()));
    };
    final Iterable<Match> mates = IterableExtensions.<Match>filter(EcoreUtil2.<Match>getAllContentsOfType(remove.eContainer(), Match.class), _function);
    final Function1<Match, Boolean> _function_1 = (Match match) -> {
      return Boolean.valueOf(((match.getIsa().getType() != null) || (match.getIsa().getChunk() != null)));
    };
    Match _last = IterableExtensions.<Match>last(IterableExtensions.<Match>filter(mates, _function_1));
    final Match mate = ((Match) _last);
    int _size = IterableExtensions.size(mates);
    boolean _equals = (_size == 0);
    if (_equals) {
      String _name = remove.getName().getName();
      String _plus = (_name + " was never referenced on the left hand side");
      this.warning(_plus, remove, 
        ModelFragmentPackage.Literals.SIMPLE_SLOT_BLOCK__NAME);
      return;
    }
    HashSet<String> allSlotNames = new HashSet<String>();
    if (((mate != null) && (mate.getIsa() != null))) {
      ChunkType _type = mate.getIsa().getType();
      boolean _tripleNotEquals = (_type != null);
      if (_tripleNotEquals) {
        allSlotNames = this._modelFragmentUtil.allSlotNames(mate.getIsa().getType());
      }
      ChunkDef _chunk = mate.getIsa().getChunk();
      boolean _tripleNotEquals_1 = (_chunk != null);
      if (_tripleNotEquals_1) {
        allSlotNames = this._modelFragmentUtil.allSlotNames(mate.getIsa().getChunk());
      }
    }
    List<SimpleSlot> _allContentsOfType = EcoreUtil2.<SimpleSlot>getAllContentsOfType(remove, SimpleSlot.class);
    for (final SimpleSlot slot : _allContentsOfType) {
      boolean _startsWith = slot.getName().startsWith("=");
      if (_startsWith) {
        EObject _eContainer = remove.eContainer();
        final HashSet<String> variables = this._modelFragmentUtil.variables(((Production) _eContainer));
        EObject _eContainer_1 = remove.eContainer();
        final boolean hasProxyOrScript = this._modelFragmentUtil.couldHaveHiddenBindings(((Production) _eContainer_1));
        boolean _contains = variables.contains(slot.getName());
        boolean _not = (!_contains);
        if (_not) {
          if ((!hasProxyOrScript)) {
            String _name_1 = slot.getName();
            String _plus_1 = (_name_1 + " was not bound on left hand side");
            this.error(_plus_1, slot, ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME, 
              ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
          } else {
            String _name_2 = slot.getName();
            String _plus_2 = (_name_2 + " was not explicitly bound, but could be by proxy or script");
            this.warning(_plus_2, slot, 
              ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
          }
        }
      } else {
        boolean _contains_1 = allSlotNames.contains(slot.getName());
        boolean _not_1 = (!_contains_1);
        if (_not_1) {
          String _name_3 = slot.getName();
          String _plus_3 = (_name_3 + " is not a known slot. available:");
          String _plus_4 = (_plus_3 + allSlotNames);
          final HashSet<String> _converted_allSlotNames = (HashSet<String>)allSlotNames;
          this.error(_plus_4, slot, 
            ModelFragmentPackage.Literals.SIMPLE_SLOT__NAME, ModelFragmentValidator.BAD_SLOT_NAME, ((String[])Conversions.unwrapArray(_converted_allSlotNames, String.class)));
        }
      }
    }
  }
  
  @Check(CheckType.FAST)
  public void checkProxy(final Proxy proxy) {
    final String className = proxy.getName();
    boolean _isValidClassName = this.isValidClassName(proxy.eResource(), className);
    boolean _not = (!_isValidClassName);
    if (_not) {
      this.error((className + " could not be found in current classpath"), proxy, ModelFragmentPackage.Literals.PROXY__NAME);
    }
  }
  
  @Check(CheckType.FAST)
  public void checkVariablesInRHS(final Production production) {
    final HashSet<String> variables = this._modelFragmentUtil.variables(production);
    final boolean hasProxyOrScript = this._modelFragmentUtil.couldHaveHiddenBindings(production);
    final Consumer<ProductionAction> _function = (ProductionAction action) -> {
      final Consumer<Value> _function_1 = (Value value) -> {
        boolean _isVariable = this._modelFragmentUtil.isVariable(value);
        if (_isVariable) {
          boolean _contains = variables.contains(value.getName());
          boolean _not = (!_contains);
          if (_not) {
            EReference literal = ModelFragmentPackage.Literals.CONDITIONAL_SLOT__VALUE;
            EObject _eContainer = value.eContainer();
            if ((_eContainer instanceof SimpleSlot)) {
              literal = ModelFragmentPackage.Literals.SIMPLE_SLOT__VALUE;
            }
            if ((!hasProxyOrScript)) {
              String _name = value.getName();
              String _plus = (_name + " was not bound on left hand side");
              this.error(_plus, value.eContainer(), literal, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
            } else {
              String _name_1 = value.getName();
              String _plus_1 = (_name_1 + 
                " was not explicitly bound, but could be provided at runtime by proxy, script, or meta");
              this.warning(_plus_1, 
                value.eContainer(), literal, ModelFragmentValidator.BAD_VARIABLE, ((String[])Conversions.unwrapArray(variables, String.class)));
            }
          }
        }
      };
      EcoreUtil2.<Value>getAllContentsOfType(action, Value.class).forEach(_function_1);
    };
    EcoreUtil2.<ProductionAction>getAllContentsOfType(production, ProductionAction.class).forEach(_function);
  }
}
