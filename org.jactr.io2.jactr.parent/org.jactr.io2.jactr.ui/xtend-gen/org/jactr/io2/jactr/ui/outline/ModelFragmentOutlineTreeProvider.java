/**
 * generated by Xtext 2.16.0
 */
package org.jactr.io2.jactr.ui.outline;

import java.util.Arrays;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
import org.eclipse.xtext.ui.editor.outline.impl.EStructuralFeatureNode;
import org.jactr.io2.jactr.modelFragment.Buffer;
import org.jactr.io2.jactr.modelFragment.Buffers;
import org.jactr.io2.jactr.modelFragment.ConditionalSlot;
import org.jactr.io2.jactr.modelFragment.Element;
import org.jactr.io2.jactr.modelFragment.ModelExtension;
import org.jactr.io2.jactr.modelFragment.ModelModule;
import org.jactr.io2.jactr.modelFragment.PackageDeclaration;
import org.jactr.io2.jactr.modelFragment.SimpleSlot;

/**
 * Customization of the default outline structure.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#outline
 */
@SuppressWarnings("all")
public class ModelFragmentOutlineTreeProvider extends DefaultOutlineTreeProvider {
  protected boolean _isLeaf(final SimpleSlot slot) {
    return true;
  }
  
  protected boolean _isLeaf(final ConditionalSlot slot) {
    return true;
  }
  
  protected void _createChildren(final IOutlineNode outlineNode, final PackageDeclaration dec) {
    final Consumer<ModelModule> _function = (ModelModule n) -> {
      this.createNode(outlineNode, n);
    };
    dec.getModules().forEach(_function);
    final Consumer<ModelExtension> _function_1 = (ModelExtension n) -> {
      this.createNode(outlineNode, n);
    };
    dec.getExtensions().forEach(_function_1);
    Buffers _buffers = null;
    if (dec!=null) {
      _buffers=dec.getBuffers();
    }
    EList<Buffer> _buffers_1 = null;
    if (_buffers!=null) {
      _buffers_1=_buffers.getBuffers();
    }
    if (_buffers_1!=null) {
      final Consumer<Buffer> _function_2 = (Buffer n) -> {
        this.createNode(outlineNode, n);
      };
      _buffers_1.forEach(_function_2);
    }
    final Consumer<Element> _function_3 = (Element n) -> {
      this.createNode(outlineNode, n);
    };
    dec.getElements().forEach(_function_3);
  }
  
  protected void _createChildren(final IOutlineNode outlineNode, final SimpleSlot slot) {
  }
  
  protected void _createChildren(final IOutlineNode outlineNode, final ConditionalSlot slot) {
  }
  
  public boolean isLeaf(final Object slot) {
    if (slot instanceof ConditionalSlot) {
      return _isLeaf((ConditionalSlot)slot);
    } else if (slot instanceof SimpleSlot) {
      return _isLeaf((SimpleSlot)slot);
    } else if (slot instanceof EObject) {
      return _isLeaf((EObject)slot);
    } else if (slot != null) {
      return _isLeaf(slot);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(slot).toString());
    }
  }
  
  public void createChildren(final IOutlineNode outlineNode, final EObject slot) {
    if (outlineNode instanceof DocumentRootNode
         && slot != null) {
      _createChildren((DocumentRootNode)outlineNode, slot);
      return;
    } else if (outlineNode instanceof EStructuralFeatureNode
         && slot != null) {
      _createChildren((EStructuralFeatureNode)outlineNode, slot);
      return;
    } else if (outlineNode != null
         && slot instanceof ConditionalSlot) {
      _createChildren(outlineNode, (ConditionalSlot)slot);
      return;
    } else if (outlineNode != null
         && slot instanceof PackageDeclaration) {
      _createChildren(outlineNode, (PackageDeclaration)slot);
      return;
    } else if (outlineNode != null
         && slot instanceof SimpleSlot) {
      _createChildren(outlineNode, (SimpleSlot)slot);
      return;
    } else if (outlineNode != null
         && slot != null) {
      _createChildren(outlineNode, slot);
      return;
    } else if (outlineNode != null
         && slot != null) {
      _createChildren(outlineNode, slot);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(outlineNode, slot).toString());
    }
  }
}
